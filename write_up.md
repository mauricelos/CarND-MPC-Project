# CarND-Controls-MPC
Self-Driving Car Engineer Nanodegree Program

---

Student describes their model in detail. This includes the state, actuators and update equations. A polynomial is fitted to waypoints. If the student preprocesses waypoints, the vehicle state, and/or actuators prior to the MPC procedure it is described. The student implements Model Predictive Control that handles a 100 millisecond latency. Student provides details on how they deal with latency.

In main.cpp I took the waypoints (ptsx/ptsy) and converted them from the global coordinate system to the cars coordinate system. In order to do that I had to subtract the cars coordinates from the global waypoints coordinates and shift everything by 90 degrees, because the global y axes is the cars initial x axes at zero psi. Then I converted the transformed waypoints from normal vectors to Eigen::VectorXd in order to use them with the polyfit function. By changing the waypoint to car space it's a lot easier to calculate cte and epsi, because px/py is now the orgin (0/0) of the coordinate system, the orientation (psi) is also zero! To compensate the 100 milisecond latency I added latency corrections to all state values (eg.: adding the distance traveled in 100 milisecond to px (px = velocity*latency))! After that all state values and the calculated coeffs are proccessed in MPC::Solve, where we set the constraints lower and upper bounds for all values and the number of variables and constraints. The coeffs are then handed to FG_eval where the cost is defined and the next state is comupted. Then we call the optimization solver, in this case the ipopt solver, which gives out the solution value for all state values and the actuations. In main.cpp I also took all predicted x and y values and used them for the MPC predicted trajectory. Instead of just drawing the predicted trajectory with the given x/y values I decided to calculate a function with polyfit and use the function to draw the line. I did the same for the reference trajectory, which was computed with the already existing coeffs for the waypoints (transformed in car space). The actual points for mpc trajectory and reference trajectory where computed using the polyeval fuction and a for-loop to increase x.


Student discusses the reasoning behind the chosen N (timestep length) and dt (timestep frequency) values. Additionally the student details the previous values tried.

I decided to set N to 15 and dt to 0.1, which results in a prediction horizon of 1.5 seconds, which helps in a fast changing enviroment (like in the tighter turns in the middle of the track) to predict the right path. I tried a lot of different combinations and I think it's really dependent on the scenario the car is in. If the car drives faster and/or has to drive through tight turns the prediction horizon has to be lower, because the car approaches turns faster and/or has to correct more frequently due to changing turns. On a relativly straight road the prediction horizon can be a lot longer as there aren't much places where the trajectory has to be changed drastically.
